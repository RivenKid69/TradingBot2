# Математический анализ формулы Parkinson: n vs valid_bars

## Вопрос: что должно быть в знаменателе при пропусках данных?

### Оригинальная формула Parkinson (1980):

```
σ² = (1/(4·n·ln(2))) · Σ(ln(H_i/L_i))²
```

где n - "number of observations" (количество наблюдений)

---

## Статистическая интерпретация

### Теоретическая основа:

Parkinson показал, что для геометрического броуновского движения:

```
E[(ln(H/L))²] = 4·ln(2)·σ²
```

где σ² - дисперсия за один период.

### Оценка по выборке:

Чтобы оценить математическое ожидание E[X] по выборке из N наблюдений:

```
E[X] ≈ (1/N) · Σ(X_i)
```

где **N = количество слагаемых в сумме**

Применяя к Parkinson:

```
E[(ln(H/L))²] ≈ (1/N) · Σ(ln(H_i/L_i))²
```

Подставляя в формулу:

```
σ² ≈ (1/(4·ln(2))) · (1/N) · Σ(ln(H_i/L_i))²
σ² = Σ(ln(H_i/L_i))² / (4·N·ln(2))
```

**где N = количество фактических наблюдений = valid_bars**

---

## Численный пример

Допустим:
- Окно: n = 12 баров (48 часов для 4h интервала)
- Валидных: 9 баров (3 пропуска)
- sum_sq = Σ(ln(H_i/L_i))² = 0.05 (суммируем 9 слагаемых)

### Вариант A: Делим на valid_bars = 9

```
σ² = 0.05 / (4 × 9 × ln(2))
σ² = 0.05 / (36 × 0.693147)
σ² = 0.05 / 24.953
σ² = 0.002003
σ = 0.0448
```

### Вариант B: Делим на n = 12

```
σ² = 0.05 / (4 × 12 × ln(2))
σ² = 0.05 / (48 × 0.693147)
σ² = 0.05 / 33.271
σ² = 0.001502
σ = 0.0388
```

### Анализ:

**Вариант A (valid_bars):** Оценивает среднее 9 наблюдений как sum/9 ✅
**Вариант B (n):** Оценивает среднее 9 наблюдений как sum/12 ❌

Вариант B **занижает** среднее (и дисперсию) на ~25%!

---

## Аналогия с обычным средним

Рассмотрим простой пример:

```python
# Данные: окно 5, валидных 3
data = [10, 20, NaN, NaN, 30]
valid_data = [10, 20, 30]  # sum = 60

# Правильное среднее:
mean = 60 / 3 = 20.0  ✅

# Если делим на размер окна:
wrong_mean = 60 / 5 = 12.0  ❌ (занижено на 40%!)
```

**То же самое с Parkinson:** делить нужно на количество слагаемых, а не на размер окна.

---

## Риски для трейдинга

### Сценарий с использованием n (заниженная волатильность):

1. **Волатильность занижена** на 13-25% при пропусках
2. **Модель недооценивает риск**
3. **Позиции слишком большие** (risk sizing: position ∝ 1/volatility)
4. **Потенциально большие потери** при неожиданных движениях

**Это ОПАСНЕЕ, чем завышение волатильности!**

Завышение → меньшие позиции → упущенная прибыль (не так критично)
Занижение → большие позиции → большие потери (критично!)

---

## Что говорят источники?

### Stack Exchange (quant.stackexchange.com):
```python
rs = (np.log(high/low)**2).rolling(window).sum()
result = (rs / (const * trading_periods)) ** 0.5
```
- Используют `trading_periods` в знаменателе
- НО: `.rolling().sum()` в pandas пропускает NaN, возвращая сумму только валидных
- Для полных данных: trading_periods = window = valid_count
- **При пропусках: нужно корректировать на фактическое количество**

### Статистическая практика:
- "Skip days with missing data"
- **"Adjust n to equal the actual number of valid observations"**
- "Ensures the denominator accurately reflects the sample size"

---

## ВЫВОД

### ✅ ПРАВИЛЬНАЯ формула (оригинальная):
```python
parkinson_var = sum_sq / (4 * valid_bars * math.log(2))
```

**Обоснование:**
- Соответствует статистическому принципу: среднее = сумма / количество_слагаемых
- Дает несмещенную оценку σ²
- Стандартная практика при пропусках данных

### ❌ НЕПРАВИЛЬНАЯ формула (мое "исправление"):
```python
parkinson_var = sum_sq / (4 * n * math.log(2))  # ОШИБКА!
```

**Проблема:**
- Систематически ЗАНИЖАЕТ волатильность на 10-25%
- Нарушает статистический принцип оценки среднего
- ОПАСНО для риск-менеджмента (недооценка рисков)

---

## Действие: ОТКАТИТЬ изменение

Нужно вернуться к оригинальной формуле с `valid_bars`.

**Автор анализа:** Claude Code
**Дата:** 2025-11-15
**Статус:** Критическая ошибка обнаружена в моем "исправлении"
