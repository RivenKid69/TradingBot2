"""Spot signal transport models and signing helpers."""
from __future__ import annotations

import hashlib
import hmac
import json
import math
from pathlib import Path
from typing import Any, Dict, Mapping, MutableMapping, Optional, Union, Literal

from pydantic import BaseModel, Field, ConfigDict, field_validator, model_validator

__all__ = [
    "SpotSignalEconomics",
    "SpotSignalTwapConfig",
    "SpotSignalTargetWeightPayload",
    "SpotSignalDeltaParticipationPayload",
    "SpotSignalPayload",
    "SpotSignalEnvelope",
    "compute_signature",
    "sign_envelope",
    "verify_envelope",
    "export_json_schema",
    "build_envelope",
]


def _model_dump(obj: Any, **kwargs: Any) -> Dict[str, Any]:
    """Return a serialisable representation for ``obj``."""

    dump = getattr(obj, "model_dump", None)
    if callable(dump):
        return dump(**kwargs)
    dump = getattr(obj, "dict", None)
    if callable(dump):
        return dump(**kwargs)
    raise TypeError(f"Object of type {type(obj)!r} is not a Pydantic model")


def _model_copy(obj: Any, **kwargs: Any) -> Any:
    copier = getattr(obj, "model_copy", None)
    if callable(copier):
        return copier(**kwargs)
    copier = getattr(obj, "copy", None)
    if callable(copier):
        return copier(**kwargs)
    raise TypeError(f"Object of type {type(obj)!r} cannot be copied via Pydantic helpers")


def _model_json_schema(cls: Any) -> Dict[str, Any]:
    method = getattr(cls, "model_json_schema", None)
    if callable(method):
        return method()
    method = getattr(cls, "schema", None)
    if callable(method):
        return method()
    raise TypeError(f"Class {cls!r} does not expose a JSON schema method")


def _ensure_bytes(secret: Union[str, bytes]) -> bytes:
    if isinstance(secret, bytes):
        return secret
    return secret.encode("utf-8")


class SpotSignalEconomics(BaseModel):
    """Estimated economics for a spot rebalance signal."""

    edge_bps: float = Field(..., description="Gross signal edge in basis points.")
    cost_bps: float = Field(..., description="Estimated total cost in basis points.")
    net_bps: float = Field(..., description="Net edge after subtracting costs.")
    turnover_usd: float = Field(
        ..., ge=0.0, description="Expected turnover generated by the signal in USD."
    )
    act_now: bool = Field(..., description="Whether the rebalance should execute immediately.")
    impact: float = Field(
        0.0,
        ge=0.0,
        description="Estimated participation-driven impact component in basis points.",
    )
    impact_mode: Optional[str] = Field(
        "model",
        description=(
            "Mode describing how the impact estimate was produced (e.g. 'model' or 'none')."
        ),
    )
    adv_quote: Optional[float] = Field(
        None,
        ge=0.0,
        description="Average daily quote volume used for participation modelling.",
    )

    @field_validator("net_bps")
    @classmethod
    def _validate_net_bps(cls, value: float) -> float:
        return float(value)

    @field_validator("turnover_usd")
    @classmethod
    def _validate_turnover(cls, value: float) -> float:
        if value < 0.0:
            raise ValueError("turnover_usd must be non-negative")
        return float(value)

    @field_validator("impact")
    @classmethod
    def _validate_impact(cls, value: float) -> float:
        if value < 0.0:
            return 0.0
        return float(value)

    @field_validator("adv_quote")
    @classmethod
    def _validate_adv(cls, value: Optional[float]) -> Optional[float]:
        if value is None:
            return None
        coerced = float(value)
        if coerced <= 0.0 or not math.isfinite(coerced):
            return None
        return coerced


class SpotSignalTwapConfig(BaseModel):
    """Optional slicing configuration for delta-style payloads."""

    parts: int = Field(1, ge=1, description="Number of slices to execute.")
    interval_s: Optional[float] = Field(
        None,
        gt=0.0,
        description="Interval between slices in seconds. Mutually exclusive with interval_ms.",
    )
    interval_ms: Optional[int] = Field(
        None,
        ge=0,
        description="Interval between slices in milliseconds. Overrides interval_s when provided.",
    )
    max_participation: Optional[float] = Field(
        None,
        ge=0.0,
        description="Maximum participation (fraction of ADV) per slice.",
    )

    @field_validator("max_participation")
    @classmethod
    def _clamp_participation(cls, value: Optional[float]) -> Optional[float]:
        if value is None:
            return None
        return max(0.0, float(value))


class _BasePayload(BaseModel):
    economics: SpotSignalEconomics

    model_config = ConfigDict(frozen=True)


class SpotSignalTargetWeightPayload(_BasePayload):
    """Spot signal targeting an absolute portfolio weight."""

    kind: Literal["target_weight"] = "target_weight"
    target_weight: float = Field(..., ge=0.0, le=1.0, description="Desired portfolio weight.")


class SpotSignalDeltaParticipationPayload(_BasePayload):
    """Spot signal describing a delta weight adjustment with optional participation hints."""

    kind: Literal["delta_weight"] = "delta_weight"
    delta_weight: float = Field(
        ...,
        description="Relative change in portfolio weight (positive increases exposure).",
    )
    participation: Optional[float] = Field(
        None,
        ge=0.0,
        description="Optional participation hint (0..1) for POV style execution.",
    )
    max_participation: Optional[float] = Field(
        None,
        ge=0.0,
        description="Optional cap on participation used for scheduling child orders.",
    )
    twap: Optional[SpotSignalTwapConfig] = Field(
        None, description="Optional configuration for TWAP style slicing."
    )

    @field_validator("max_participation")
    @classmethod
    def _clamp_max_participation(cls, value: Optional[float]) -> Optional[float]:
        if value is None:
            return None
        return max(0.0, float(value))


SpotSignalPayload = Union[SpotSignalTargetWeightPayload, SpotSignalDeltaParticipationPayload]


def _coerce_payload(payload: Any) -> SpotSignalPayload:
    if isinstance(payload, (SpotSignalTargetWeightPayload, SpotSignalDeltaParticipationPayload)):
        return payload
    if isinstance(payload, Mapping):
        data = dict(payload)
        kind = data.get("kind")
        if kind is None:
            if "target_weight" in data:
                kind = "target_weight"
            elif "delta_weight" in data:
                kind = "delta_weight"
        data["kind"] = kind
        if kind == "target_weight":
            return SpotSignalTargetWeightPayload.model_validate(data)
        if kind == "delta_weight":
            return SpotSignalDeltaParticipationPayload.model_validate(data)
    raise TypeError("Unsupported payload type for spot signal")


class SpotSignalEnvelope(BaseModel):
    """Wrapper adding metadata and optional signature to a spot signal payload."""

    version: Literal["v1"] = "v1"
    symbol: str = Field(..., description="Trading symbol this signal applies to.")
    bar_close_ms: int = Field(..., ge=0, description="Bar close timestamp in milliseconds.")
    expires_at_ms: int = Field(..., ge=0, description="Signal expiry timestamp in milliseconds.")
    payload: SpotSignalPayload
    signature: Optional[str] = Field(None, description="Optional HMAC-SHA256 signature.")

    model_config = ConfigDict(frozen=True)

    @model_validator(mode="after")
    def _check_expiry(self) -> "SpotSignalEnvelope":
        if int(self.expires_at_ms) < int(self.bar_close_ms):
            raise ValueError("expires_at_ms must be greater or equal to bar_close_ms")
        return self

    def canonical_dict(self) -> Dict[str, Any]:
        data = _model_dump(self, by_alias=True, exclude_none=True)
        data.pop("signature", None)
        return data

    def canonical_json(self) -> str:
        return json.dumps(self.canonical_dict(), separators=(",", ":"), sort_keys=True)

    def canonical_bytes(self) -> bytes:
        return self.canonical_json().encode("utf-8")

    def to_wire(self) -> Dict[str, Any]:
        return _model_dump(self, by_alias=True, exclude_none=True)

    def with_signature(self, signature: str) -> "SpotSignalEnvelope":
        return _model_copy(self, update={"signature": signature})


def compute_signature(message: Union[str, bytes], secret: Union[str, bytes]) -> str:
    """Compute an HMAC-SHA256 signature for ``message``."""

    msg = message.encode("utf-8") if isinstance(message, str) else message
    key = _ensure_bytes(secret)
    return hmac.new(key, msg, hashlib.sha256).hexdigest()


def sign_envelope(envelope: SpotSignalEnvelope, secret: Union[str, bytes]) -> SpotSignalEnvelope:
    signature = compute_signature(envelope.canonical_bytes(), secret)
    return envelope.with_signature(signature)


def verify_envelope(envelope: SpotSignalEnvelope, secret: Union[str, bytes]) -> bool:
    if envelope.signature is None:
        return False
    expected = compute_signature(envelope.canonical_bytes(), secret)
    return hmac.compare_digest(envelope.signature, expected)


def export_json_schema(path: Union[str, Path]) -> Path:
    """Write the envelope JSON schema to ``path``."""

    schema = _model_json_schema(SpotSignalEnvelope)
    target_path = Path(path)
    target_path.write_text(json.dumps(schema, indent=2, sort_keys=True) + "\n", encoding="utf-8")
    return target_path


def build_envelope(
    *,
    symbol: str,
    bar_close_ms: int,
    expires_at_ms: int,
    payload: Any,
    signature: Optional[str] = None,
) -> SpotSignalEnvelope:
    coerced_payload = _coerce_payload(payload)
    envelope = SpotSignalEnvelope(
        symbol=symbol,
        bar_close_ms=int(bar_close_ms),
        expires_at_ms=int(expires_at_ms),
        payload=coerced_payload,
        signature=signature,
    )
    return envelope
