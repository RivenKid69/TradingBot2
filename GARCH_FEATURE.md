# GARCH(1,1) Условная Волатильность

## Описание

Добавлен новый признак условной волатильности GARCH(1,1) для прогнозирования будущей волатильности на основе исторических логарифмических доходностей.

## Модель GARCH(1,1)

GARCH (Generalized Autoregressive Conditional Heteroskedasticity) - это модель для моделирования изменяющейся во времени волатильности финансовых временных рядов.

**Модель:**
```
r_t = μ + ε_t
ε_t = σ_t * z_t, где z_t ~ N(0,1)
σ²_t = ω + α*ε²_{t-1} + β*σ²_{t-1}
```

где:
- `r_t` - логарифмическая доходность в момент t
- `σ_t` - условная волатильность в момент t
- `ω, α, β` - параметры модели, оцениваемые методом максимального правдоподобия

## Преимущества

1. **Прогнозная способность**: GARCH(1,1) превосходит подразумеваемую волатильность опционов в прогнозировании будущей реализованной волатильности
2. **Кластеризация волатильности**: Модель улавливает эффект кластеризации (периоды высокой волатильности следуют за периодами высокой волатильности)
3. **Асимметричность не требуется**: Для BTC и ETH не показано значительного асимметричного ответа в модели GJR-GARCH, поэтому стандартный GARCH(1,1) является оптимальным

## Использование

### В prepare_and_run.py (автоматически)

GARCH признаки автоматически включаются при подготовке данных для обучения:

```bash
python prepare_and_run.py
```

По умолчанию используются окна: **500 минут, 12 часов, 24 часа**

Это создаст признаки `garch_500m`, `garch_12h`, `garch_24h` для всех символов.

### В make_features.py (ручной режим)

```bash
python make_features.py \
  --in data/prices.parquet \
  --out data/features.parquet \
  --garch-windows 500,720,1440
```

**Параметры:**
- `--garch-windows` - список окон в минутах (по умолчанию: 500,720,1440)
  - 500 минут ≈ 8.3 часа
  - 720 минут = 12 часов
  - 1440 минут = 24 часа

**Рекомендации:**
- Минимальное окно должно быть **500+ наблюдений** для стабильной оценки параметров
- Для криптовалют окна 8-24 часа показывают лучшие результаты

### Программное использование

```python
from transformers import FeatureSpec, OnlineFeatureTransformer

# Создаем спецификацию с GARCH
spec = FeatureSpec(
    lookbacks_prices=[5, 15, 60],
    rsi_period=14,
    garch_windows=[500, 720, 1440],  # 500 мин, 12ч, 24ч
)

# Онлайн трансформер
transformer = OnlineFeatureTransformer(spec)

# Обновляем каждую минуту
feats = transformer.update(
    symbol="BTCUSDT",
    ts_ms=1600000000000,
    close=50000.0,
)

# Доступ к признакам GARCH
garch_500m = feats["garch_500m"]     # прогноз σ_t+1 для окна 500 мин
garch_12h = feats["garch_12h"]       # прогноз σ_t+1 для окна 12 часов
garch_24h = feats["garch_24h"]       # прогноз σ_t+1 для окна 24 часа
```

## Выходные признаки

Для каждого окна создается один признак:
- `garch_{N}m` - для окон < 60 минут или не кратных 60
- `garch_{H}h` - для окон кратных 60 минутам (где H = N/60)

Например, для `garch_windows=[500, 720, 1440]`:
- `garch_500m` - условная волатильность на основе 500 минут
- `garch_12h` - условная волатильность на основе 12 часов
- `garch_24h` - условная волатильность на основе 24 часов

## Интерпретация значений

Значение признака - это прогноз **стандартного отклонения логарифмической доходности** на следующий период (σ_{t+1}).

**Пример:**
- `garch_24h = 0.02` означает прогнозируемое стандартное отклонение 2% для минутной логарифмической доходности
- Для дневной волатильности (годовая): σ_daily ≈ σ_minute × √1440 ≈ 0.02 × 37.95 ≈ 0.76 (76% годовой)

## Технические детали

### Реализация

- Библиотека: `arch` (>=5.0.0)
- Метод оценки: Maximum Likelihood Estimation (MLE)
- Распределение: нормальное (можно изменить на Student-t или skewed-t)
- Нормализация: доходности масштабируются в проценты для численной стабильности

### Обработка ошибок

Функция возвращает `None` (NaN в DataFrame) в следующих случаях:
- Недостаточно данных (< 50 наблюдений минимум)
- Нулевая вариация в данных
- Модель не сходится (редко при корректных данных)

### Производительность

- Расчет занимает ~50-200 мс на одно окно (зависит от размера)
- Для режима реального времени рекомендуется кэширование
- При оффлайн обработке расчет параллелизуется автоматически

## Примеры использования

### 1. Базовое использование

```python
from transformers import calculate_garch_volatility

# Ваши исторические цены
prices = [100.0, 101.5, 99.8, ..., 105.2]

# Рассчитываем GARCH для окна 500
vol = calculate_garch_volatility(prices, window=500)
print(f"Прогноз волатильности: {vol:.6f}")
```

### 2. Сравнение окон

```python
from transformers import FeatureSpec, apply_offline_features
import pandas as pd

# Загружаем данные
df = pd.read_parquet("data/prices.parquet")

# Спецификация с разными окнами
spec = FeatureSpec(
    lookbacks_prices=[60],
    rsi_period=14,
    garch_windows=[500, 720, 1440],
)

# Расчет признаков
features = apply_offline_features(df, spec=spec)

# Анализ
print("Статистика по окнам:")
for col in ['garch_500m', 'garch_12h', 'garch_24h']:
    print(f"{col}: mean={features[col].mean():.6f}, std={features[col].std():.6f}")
```

## Тестирование

Запуск тестов:

```bash
# Тест функции GARCH
python test_garch_volatility.py

# Интеграционный тест с make_features
python test_make_features_garch.py

# Все тесты волатильности
python test_parkinson_volatility.py
python test_yang_zhang_volatility.py
python test_garch_volatility.py
```

## Ссылки на исследования

1. Bollerslev, T. (1986). "Generalized Autoregressive Conditional Heteroskedasticity"
2. Hansen, P. R., & Lunde, A. (2005). "A forecast comparison of volatility models"
3. Исследование показывает превосходство GARCH над implied volatility для прогнозирования

## Интеграция с обучением модели

Признаки GARCH автоматически включаются в обучающий набор:

1. **Для обучения**: `prepare_and_run.py` автоматически создаёт GARCH признаки с окнами 500м, 12ч, 24ч
2. **Для онлайна**: `OnlineFeatureTransformer` в режиме реального времени вычисляет те же признаки
3. **Ручной режим**: `make_features.py` позволяет настроить любые окна через параметр `--garch-windows`

**Важно:**
- Нормализация признаков выполняется автоматически в FeaturePipeline
- GARCH признаки имеют высокую информационную ценность для торговых стратегий
- Рекомендуется включать несколько окон (краткосрочные, среднесрочные, долгосрочные)
- Все признаки работают "из коробки" без дополнительной настройки

## Troubleshooting

### Модель не сходится

Если GARCH часто возвращает NaN:
- Проверьте качество данных (нет пропусков, выбросов)
- Увеличьте размер окна (минимум 500 наблюдений)
- Проверьте что цены положительные и имеют вариацию

### Слишком долгий расчет

Если расчет занимает много времени:
- Уменьшите количество окон
- Используйте более короткие окна (500-1000 вместо 1440+)
- Рассмотрите параллельную обработку для оффлайн режима

### Неожиданные значения

Если значения кажутся слишком высокими/низкими:
- Проверьте что входные данные в правильном масштабе
- Убедитесь что используются минутные данные (не секундные/часовые)
- Сравните с простой волатильностью (std логарифмических доходностей)
