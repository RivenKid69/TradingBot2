# Parkinson Range Volatility Feature

## Описание

Волатильность диапазона Паркинсона (Parkinson Range Volatility) - это эффективный оценщик волатильности, который использует информацию о дневном диапазоне High-Low для более точного измерения волатильности по сравнению с традиционным методом close-to-close.

Оценщик Паркинсона **в 7,4 раза более эффективен**, чем оценщик close-to-close при одинаковом количестве данных.

## Формула

```
σ_Parkinson = sqrt[(1/(4n·log(2))) · Σ(log(H_i/L_i))²]
```

где:
- **n** - размер окна (количество баров)
- **H_i** - максимальная цена (High) i-го бара
- **L_i** - минимальная цена (Low) i-го бара
- **log** - натуральный логарифм

## Преимущества

1. **Высокая эффективность**: В 7,4 раза эффективнее стандартного close-to-close оценщика
2. **Использование диапазона**: Учитывает всю информацию о внутридневном движении цены
3. **Простота**: Требует только High и Low цены, не требует информации о моментах времени
4. **Научная обоснованность**: Парkinson (1980) доказал оптимальность этого оценщика для процесса Броуновского движения

## Сравнение с другими методами

| Метод | Используемые данные | Эффективность | Применение |
|-------|---------------------|---------------|------------|
| **Close-to-Close** | Close | 1.0x (базовый) | Только цены закрытия |
| **Parkinson** | High, Low | **7.4x** | Есть OHLC данные |
| **Garman-Klass** | Open, High, Low, Close | 7.9x | Полные OHLC, без gaps |
| **Yang-Zhang** | Open, High, Low, Close | 14.9x | Полные OHLC, с gaps |

Parkinson оптимален когда:
- Доступны данные High/Low
- Нужна простая и быстрая оценка волатильности
- Важна эффективность при ограниченных данных

## Конфигурация

В `prepare_and_run.py`:

```python
feature_spec = FeatureSpec(
    lookbacks_prices=[5, 15, 60],
    rsi_period=14,
    # Parkinson volatility windows (in minutes)
    parkinson_windows=[1440, 10080],  # 24h, 7d
)
```

### Параметры

- **parkinson_windows**: список окон в минутах для расчета волатильности
  - `1440` = 24 часа (1 день)
  - `10080` = 168 часов (7 дней)

По умолчанию используются окна 24ч и 168ч, так как они обеспечивают:
- **24ч**: Краткосрочная волатильность для внутридневных паттернов
- **168ч**: Среднесрочная волатильность для недельных трендов

## Использование

### Онлайн (real-time)

```python
from transformers import FeatureSpec, OnlineFeatureTransformer

spec = FeatureSpec(
    lookbacks_prices=[5, 15, 60],
    rsi_period=14,
    parkinson_windows=[1440, 10080]  # 24h, 7d
)

transformer = OnlineFeatureTransformer(spec)

# Обработка бара с High/Low данными
feats = transformer.update(
    symbol="BTCUSDT",
    ts_ms=1234567890000,
    close=50000.0,
    open_price=49900.0,
    high=50100.0,  # Необходимо для Parkinson
    low=49800.0,   # Необходимо для Parkinson
)

# Доступ к признакам
print(feats['parkinson_24h'])   # Волатильность за 24 часа
print(feats['parkinson_168h'])  # Волатильность за 7 дней
```

### Оффлайн (batch processing)

```python
from transformers import FeatureSpec, apply_offline_features
import pandas as pd

# Загрузка данных с OHLC
df = pd.read_parquet("data/klines.parquet")

spec = FeatureSpec(
    lookbacks_prices=[5, 15, 60],
    rsi_period=14,
    parkinson_windows=[1440, 10080]
)

# Расчет признаков
features = apply_offline_features(
    df,
    spec=spec,
    ts_col="ts_ms",
    symbol_col="symbol",
    price_col="close",
    high_col="high",  # Необходимо для Parkinson
    low_col="low",    # Необходимо для Parkinson
)
```

## Выходные признаки

Для каждого окна создается признак с именем `parkinson_{hours}h`:

- `parkinson_24h` - волатильность за 24 часа
- `parkinson_168h` - волатильность за 7 дней

Значения:
- **Число > 0**: рассчитанная волатильность (стандартное отклонение)
- **NaN**: недостаточно данных для расчета или невалидные данные (High < Low)

## Требования к данным

1. **Минимум данных**: Для окна N минут требуется как минимум N баров
2. **High/Low данные**: Необходимы значения High и Low для каждого бара
3. **Валидность**: High должен быть >= Low (проверяется автоматически)
4. **Положительные цены**: High > 0 и Low > 0
5. **Последовательность**: Данные должны быть упорядочены по времени

## Интерпретация

Значения волатильности Parkinson интерпретируются так же, как и другие меры волатильности:

- **Низкая волатильность** (< 0.01): Рынок стабилен, узкие торговые диапазоны
- **Средняя волатильность** (0.01 - 0.05): Нормальные рыночные условия
- **Высокая волатильность** (> 0.05): Широкие диапазоны, повышенный риск

### Особенности интерпретации

Parkinson волатильность отражает:
- **Внутридневную амплитуду**: Насколько широк торговый диапазон
- **Неопределенность**: Чем шире диапазон High-Low, тем выше неопределенность
- **Риск**: Высокие значения указывают на повышенный риск резких движений

## Примеры значений

Для Bitcoin (BTCUSDT):
- **Спокойный рынок**: ~0.010 - 0.020 (узкие диапазоны)
- **Нормальный рынок**: ~0.020 - 0.035 (средние диапазоны)
- **Волатильный рынок**: ~0.035 - 0.060 (широкие диапазоны)
- **Экстремальная волатильность**: > 0.060 (очень широкие диапазоны)

## Математическое обоснование

Parkinson (1980) показал, что для логарифмического Броуновского движения:

```
Var[log(H/L)] = 4·log(2)·σ²
```

Откуда следует несмещенный оценщик:

```
σ² = E[log²(H/L)] / (4·log(2))
```

Выборочная версия:

```
σ² = (1/n) · Σ[log²(H_i/L_i)] / (4·log(2))
```

Это обеспечивает:
- **Несмещенность**: E[σ_Parkinson] = σ_true
- **Эффективность**: Var[σ_Parkinson] = Var[σ_close-to-close] / 7.4
- **Оптимальность**: Минимальная дисперсия среди всех оценщиков на основе (H, L)

## Связанные файлы

- `transformers.py:103-152` - основная реализация
- `prepare_and_run.py:284` - конфигурация в пайплайне
- `test_parkinson_volatility.py` - unit тесты и примеры
- `docs/yang_zhang_volatility.md` - сравнение с Yang-Zhang

## Ссылки

- Parkinson, M. (1980). "The Extreme Value Method for Estimating the Variance of the Rate of Return". Journal of Business, 53(1), 61-65.
- Rogers, L.C.G. and Satchell, S.E. (1991). "Estimating Variance From High, Low and Closing Prices"
- Yang, D. and Zhang, Q. (2000). "Drift-Independent Volatility Estimation"

## Часто задаваемые вопросы

**Q: Почему волатильность возвращает NaN?**
A: Недостаточно исторических данных или невалидные данные (High < Low, отрицательные цены). Для окна N минут нужно минимум N баров с валидными High/Low.

**Q: Можно ли использовать только High и Low без Open и Close?**
A: Да! Parkinson использует только High и Low, что делает его проще и быстрее, чем Yang-Zhang.

**Q: Какие окна лучше использовать?**
A: По умолчанию используются:
- **24ч (1440 мин)**: Для краткосрочной волатильности и внутридневных стратегий
- **168ч (10080 мин)**: Для среднесрочной волатильности и недельных паттернов

**Q: Когда использовать Parkinson вместо Yang-Zhang?**
A: Используйте Parkinson когда:
- Нужна простая и быстрая оценка волатильности
- Важна эффективность при ограниченных данных
- Не критична учет overnight gaps

Используйте Yang-Zhang когда:
- Нужна максимальная точность
- Важен учет overnight gaps
- Доступны полные OHLC данные

**Q: Как Parkinson сравнивается с простым стандартным отклонением?**
A: Parkinson использует информацию о дневном диапазоне (High-Low), которая содержит больше информации о волатильности, чем только цены закрытия. Это дает в 7.4 раза меньшую дисперсию оценки при том же объеме данных.

**Q: Влияет ли это на производительность?**
A: Незначительно. Расчет Parkinson проще, чем Yang-Zhang, имеет сложность O(N) для окна размером N. Для типичных окон (1440-10080 минут) overhead минимален.

## Пример использования в торговой стратегии

```python
# Определение режима волатильности
if feats['parkinson_24h'] > 0.05:
    # Высокая волатильность - широкие стопы, меньший размер позиции
    regime = "high_volatility"
    position_size_multiplier = 0.5
    stop_loss_multiplier = 2.0
elif feats['parkinson_24h'] < 0.02:
    # Низкая волатильность - узкие стопы, больший размер
    regime = "low_volatility"
    position_size_multiplier = 1.5
    stop_loss_multiplier = 1.0
else:
    # Нормальная волатильность
    regime = "normal"
    position_size_multiplier = 1.0
    stop_loss_multiplier = 1.0

# Сравнение краткосрочной и долгосрочной волатильности
vol_ratio = feats['parkinson_24h'] / feats['parkinson_168h']
if vol_ratio > 1.5:
    # Резкое увеличение краткосрочной волатильности
    signal = "volatility_spike"
elif vol_ratio < 0.7:
    # Снижение краткосрочной волатильности
    signal = "volatility_contraction"
```
